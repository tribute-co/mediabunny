/*!
 * Copyright (c) 2025-present, Vanilagy and contributors
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import { Demuxer } from '../demuxer';
import { InputAudioTrack } from '../input-track';
import { assert, binarySearchExact, binarySearchLessOrEqual, last, UNDETERMINED_LANGUAGE } from '../misc';
import { EncodedPacket, PLACEHOLDER_DATA } from '../packet';
import { getXingOffset, INFO, XING } from './mp3-misc';
import { Mp3Reader } from './mp3-reader';
export class Mp3Demuxer extends Demuxer {
    constructor(input) {
        super(input);
        this.metadataPromise = null;
        this.firstFrameHeader = null;
        this.allSamples = [];
        this.tracks = [];
        this.reader = new Mp3Reader(input._mainReader);
    }
    async readMetadata() {
        return this.metadataPromise ??= (async () => {
            const fileSize = await this.input.source.getSize();
            this.reader.fileSize = fileSize;
            // Just load the entire file. Primitive, but the only way to actually ensure 100% correct timestamps.
            // Random access in MP3 can be flaky and unreliable.
            await this.reader.reader.loadRange(0, fileSize);
            const id3Tag = this.reader.readId3();
            if (id3Tag) {
                this.reader.pos += id3Tag.size;
            }
            let nextTimestampInSamples = 0;
            // Let's read all samples
            while (true) {
                const header = this.reader.readNextFrameHeader();
                if (!header) {
                    break;
                }
                const xingOffset = getXingOffset(header.mpegVersionId, header.channel);
                this.reader.pos = header.startPos + xingOffset;
                const word = this.reader.readU32();
                const isXing = word === XING || word === INFO;
                this.reader.pos = header.startPos + header.totalSize - 1; // -1 in case the frame is 1 byte too short
                if (isXing) {
                    // There's no actual audio data in this frame, so let's skip it
                    continue;
                }
                if (!this.firstFrameHeader) {
                    this.firstFrameHeader = header;
                }
                const sampleDuration = header.audioSamplesInFrame / header.sampleRate;
                const sample = {
                    timestamp: nextTimestampInSamples / header.sampleRate,
                    duration: sampleDuration,
                    dataStart: header.startPos,
                    dataSize: header.totalSize,
                };
                this.allSamples.push(sample);
                nextTimestampInSamples += header.audioSamplesInFrame;
            }
            if (!this.firstFrameHeader) {
                throw new Error('No MP3 frames found.');
            }
            this.tracks = [new InputAudioTrack(new Mp3AudioTrackBacking(this))];
        })();
    }
    async getMimeType() {
        return 'audio/mpeg';
    }
    async getTracks() {
        await this.readMetadata();
        return this.tracks;
    }
    async computeDuration() {
        await this.readMetadata();
        const lastSample = last(this.allSamples);
        assert(lastSample);
        return lastSample.timestamp + lastSample.duration;
    }
}
class Mp3AudioTrackBacking {
    constructor(demuxer) {
        this.demuxer = demuxer;
    }
    getId() {
        return 1;
    }
    async getFirstTimestamp() {
        return 0;
    }
    getTimeResolution() {
        assert(this.demuxer.firstFrameHeader);
        return this.demuxer.firstFrameHeader.sampleRate / this.demuxer.firstFrameHeader.audioSamplesInFrame;
    }
    computeDuration() {
        return this.demuxer.computeDuration();
    }
    getLanguageCode() {
        return UNDETERMINED_LANGUAGE;
    }
    getCodec() {
        return 'mp3';
    }
    getNumberOfChannels() {
        assert(this.demuxer.firstFrameHeader);
        return this.demuxer.firstFrameHeader.channel === 3 ? 1 : 2;
    }
    getSampleRate() {
        assert(this.demuxer.firstFrameHeader);
        return this.demuxer.firstFrameHeader.sampleRate;
    }
    async getDecoderConfig() {
        assert(this.demuxer.firstFrameHeader);
        return {
            codec: 'mp3',
            numberOfChannels: this.demuxer.firstFrameHeader.channel === 3 ? 1 : 2,
            sampleRate: this.demuxer.firstFrameHeader.sampleRate,
        };
    }
    getPacketAtIndex(sampleIndex, options) {
        if (sampleIndex === -1) {
            return null;
        }
        const rawSample = this.demuxer.allSamples[sampleIndex];
        if (!rawSample) {
            return null;
        }
        let data;
        if (options.metadataOnly) {
            data = PLACEHOLDER_DATA;
        }
        else {
            this.demuxer.reader.pos = rawSample.dataStart;
            data = this.demuxer.reader.readBytes(rawSample.dataSize);
        }
        return new EncodedPacket(data, 'key', rawSample.timestamp, rawSample.duration, sampleIndex, rawSample.dataSize);
    }
    async getFirstPacket(options) {
        return this.getPacketAtIndex(0, options);
    }
    async getNextPacket(packet, options) {
        const sampleIndex = binarySearchExact(this.demuxer.allSamples, packet.timestamp, x => x.timestamp);
        if (sampleIndex === -1) {
            throw new Error('Packet was not created from this track.');
        }
        return this.getPacketAtIndex(sampleIndex + 1, options);
    }
    async getPacket(timestamp, options) {
        const index = binarySearchLessOrEqual(this.demuxer.allSamples, timestamp, x => x.timestamp);
        return this.getPacketAtIndex(index, options);
    }
    getKeyPacket(timestamp, options) {
        return this.getPacket(timestamp, options);
    }
    getNextKeyPacket(packet, options) {
        return this.getNextPacket(packet, options);
    }
}
